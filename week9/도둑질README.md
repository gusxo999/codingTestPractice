## 1. 어떻게 최댓값을 구할수있을까?

### 1-1. 털수있는 집의 개수

#### 집이 2채 일경우: 1개

#### 3채 : 1개

#### 4채 : 2개

#### 5채 : 2개

#### 6채 : 3개

### 1-2 아하. 털수있는 집은 전체 N / 2 이구나 .(내림적용)

### 1-3 그리고 전체 N 이 짝수일경우 털수있는 경우의 수는 2가지고.

### 1-4 홀수 일경우?

#### [1,2,3,4,5] 가 있을경우 경우의 수는 [1,3],[2,4],[3,5],[1,4],[2,5]

#### [1,2,3,4,5,6,7] 가 있을경우 경우의 수는 [1,3,5],[1,3,6],[1,4,6],[2,4,6],[2,4,7],[2,5,7],[3,5,7]

### 1-5 아하 전체 N 개 만큼의 경우의 수가 있구나.

### 1-6 먼저 전체 N 이 주어졌을때 경우의 수를 만들어내는 알고리즘을 짜고, 그다음 모든 경우의 수를 순서대로 탐색해, 내용물을 모두 더했을때 가장 큰값인 경우의수를 찾아내는 알고리즘을 짜면되겠다.

## 2. 먼저 N이 주어졌을때 경우의 수를 만들어내는 알고리즘?

### 2-1. 가장 먼저 전체 N이 `[1,2,3,4,5,6,7]` 중 `[1]` 을 훔친다고 가정하면, 그다음 훔칠집으로 `[3,4,5,6]` 이 올수있음.

### 2-2. 오잉? 전체 N이 `[3,4,5,6]` 일 경우라고 다시 `[3]` 을 훔친다고 가정하면? 그다음 훔칠집으로 `[5,6]`이 올수있음.

### 2-3. 아하 경우의수 생성을 재귀적으로 구현할수있구나

### 2-4. 다만 몇번째집을 훔치느냐를 뭐로 정할수있을까?

### 2-4-1. 그냥 항상 첫번째 두번째 집을 털자. 그러니까 항상 아래처럼 두갈래로 나눠지는 형태

```
function scan(index){
  scan(1)
  scan(2)
}
```

## 3. 에라이 안돼잖아 ChatGPT 소환

# 도둑이 훔칠 수 있는 최대 금액 문제 (원형 집 배열)

## ✅ 문제 개요

원형으로 배치된 집들 중 인접한 두 집을 동시에 털 수 없는 상황에서, 도둑이 훔칠 수 있는 돈의 최대값을 구하는 문제입니다. 일반적인 "집털기(House Robber)" 문제의 변형입니다.

---

## ✅ 왜 DP (동적 계획법)로 접근해야만 하는가?

문제 핵심은 다음 두 가지 제약을 만족하면서 최댓값을 구하는 것입니다:

1. 인접한 집은 함께 털 수 없다.
2. 집이 원형으로 연결돼 있다.

- 인접한 걸 못 턴다는 제약은 **DP로 쉽게 해결**할 수 있습니다.
- 원형이라는 제약은 **"처음 집과 마지막 집을 동시에 털 수 없다"** 는 의미입니다.  
  → 그래서 **두 케이스로 나눠서 계산**해야 합니다.

---

## ❌ 실패한 접근 방식 요약

1. **가능한 조합을 재귀로 다 탐색하려 했다**  
   → 작은 입력에서는 가능하지만, 입력이 커지면 지수 시간복잡도 (O(2^N))로 인해 시간 초과 발생

2. **탐색 깊이를 N까지 뚫는 전략 사용**  
   → DP는 중복되는 하위 문제를 메모이제이션으로 줄이는 최적화가 가능한데, 이 방식은 그런 최적화가 없음

3. **집이 원형이라는 점을 고려하지 않고 구현**  
   → 처음과 마지막 집이 인접하다는 특성을 무시하면 잘못된 결과 도출

---

## ✅ 정답으로 인정되는 알고리즘 요약

```javascript
// money: 집마다 가진 돈 배열
function solution(money) {
  const n = money.length;

  // 일정 구간에서 인접하지 않은 집들 중 최댓값 구하는 DP 함수
  function rob(arr) {
    const len = arr.length;
    if (len === 0) return 0;
    if (len === 1) return arr[0];
    const dp = new Array(len).fill(0);
    dp[0] = arr[0];
    dp[1] = Math.max(arr[0], arr[1]);
    for (let i = 2; i < len; i++) {
      dp[i] = Math.max(dp[i - 1], dp[i - 2] + arr[i]);
    }
    return dp[len - 1];
  }

  // case 1: 0 ~ n-2 번째 집 털기 (첫 집 포함, 마지막 집 제외)
  // case 2: 1 ~ n-1 번째 집 털기 (첫 집 제외, 마지막 집 포함)
  const case1 = rob(money.slice(0, n - 1));
  const case2 = rob(money.slice(1));

  return Math.max(case1, case2);
}
```

---

## 📌 요약

- 가능한 경우의 수를 모두 나열하는 brute-force 방식은 절대 안 됨 (O(2^N))
- DP로 해결하면 O(N)으로 효율적으로 해결 가능
- 원형 배열이므로 DP 계산 범위를 두 케이스로 나누어야 함
- 이 방식은 1,000,000개 입력도 시간 제한 안에서 작동함
