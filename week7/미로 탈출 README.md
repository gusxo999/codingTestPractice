## 1. 기본적으로 길찾기 알고리즘은 4진트리 재귀형식으로 구현함. (이젠 상식으로 치부가능할까요?)

## 2. 이번 문제 특징 정리

### 2-1. 출구에 도달하기전 에 레버를 당겨야함.

### 2-2. 출구는 레버에 도달하기전 까진 그냥 평범한 통로취급임.

## 3. 결론.

### 3-1. '도착했던 칸'을 기록하는 'visitedToLever' 배열을 사용해 레버까지 도달하게하고,

### 3-2. 레버에 도착하면, 새로운 '도착했던 칸'을 기록하는 'visitedToExit' 배열을 사용해 출구까지 도달하게 알고리즘을 작성하면됨.

## 4. 잘 안되서 CHATGPT 소환

# 🔍 DFS vs BFS 비교 - 미로 탈출 문제

이 문제는 **최단 경로**를 구하는 문제이라 **BFS(너비 우선 탐색)**이 적합하고,
**DFS(깊이 우선 탐색)**은 이론상 가능하지만 비효율적이다.

---

## ✅ DFS vs BFS 차이점

| 항목           | DFS                                   | BFS                                    |
| -------------- | ------------------------------------- | -------------------------------------- |
| 목적           | 한 경로를 끝까지 파고들기             | 모든 경로를 넓게 동시에 탐색           |
| 최단 건너 보장 | ❌ 안 됨 (모든 경로를 다 탐색해야 함) | ✅ 가장 먼저 도착한 경로가 최단 건너임 |
| 구현 난이도    | 보통 (재귀 사용)                      | 보통 (큐 사용)                         |
| 성능           | 최악 O(4ⁿ): 모든 경로 다 확인해야 함  | O(N×M): 각 칸 한 번씩만 방문하면 충분  |

---

## 😓 DFS로 풀려면 어떻게 해야 하나

- 모든 가능한 경로를 **끝까지** 다 탐색해야 한다.
- `visited` 배열을 **경로마다 복사**해서 사용해야 한다.  
  (그렇게 해야 다른 경로에 영향 안 줍)
- `S → L`, `L → E` **두 구간 모두 DFS로 나누어 탐색해야 함**
- 최단 건너를 구하려면 가능한 모든 경로에서 **최소 건너 갱신**이 필요

---

## ✅ 결론

- **BFS가 이 문제의 정답 알고리즘**이다.
- **DFS는 가능하지만 실용적이지 않음** → 시간 초과나 복지화 구현 발생 가능
