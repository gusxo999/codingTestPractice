## 1. 사전의 정렬규칙을 이해하기 위해 순서를 나열해봤습니다.

### 1.1

#### "A" = 1,

#### "AA" = 2

#### "AAA" = 3

#### "AAAA" = 4

#### "AAAAA" = 5

#### "AAAAE" = 6

#### "AAAAI" = 7

#### "AAAAO" = 8

#### "AAAAU" = 9

#### "AAAE" = 10

#### "AUUUU" = x

#### "E" = x + 1 (추측)

### 1.2 적어봐도 코드적으로 명확하게 표현될만한 규칙이 잘안보임. 어떻게하면 AAAAU 다음에 AAAE를 오게할수있을까? 모르겠으니 일단 때려 맞춰봐야겠다.

## 2. 안돼서 CHATGPT 소환

이 문제는 사전 순서를 **사전 조합 생성 없이 수학적으로 계산**해야 효율적으로 풀 수 있어.  
**핵심 아이디어**는 다음과 같아:

---

## ✅ 핵심 아이디어

모음 `'A', 'E', 'I', 'O', 'U'`를 **인덱스 기준 (0 ~ 4)** 로 두고,  
**각 자리에서의 가능한 단어 수**를 가중치로 두어 계산하는 방식이야.

---

## ✅ 각 자릿수에서의 가중치 (weight)

예를 들어, 첫 글자 자리는 총 몇 개 단어를 만들 수 있는지 보면:

| 자리  | 가능한 단어 수                      |
| ----- | ----------------------------------- |
| 1자리 | 1 (본인) + 5 + 25 + 125 + 625 = 781 |
| 2자리 | 1 + 5 + 25 + 125 = 156              |
| 3자리 | 1 + 5 + 25 = 31                     |
| 4자리 | 1 + 5 = 6                           |
| 5자리 | 1                                   |

각 자리마다 `5^i` 의 누적합 형태로 가중치가 생기는데, 실제 계산은 아래처럼:

```ts
const weights = [781, 156, 31, 6, 1];
```

---

## ✅ 코드 예시 (TypeScript or JavaScript)

```ts
function solution(word: string): number {
  const vowels = ["A", "E", "I", "O", "U"];
  const weights = [781, 156, 31, 6, 1];

  let answer = 0;
  for (let i = 0; i < word.length; i++) {
    const idx = vowels.indexOf(word[i]);
    answer += idx * weights[i] + 1;
  }

  return answer;
}
```

---

## ✅ 설명 예시: `"AAAAE"` 계산

```plaintext
"A" (0) → 0 * 781 + 1 = 1
"A" (0) → 0 * 156 + 1 = 1
"A" (0) → 0 * 31  + 1 = 1
"A" (0) → 0 * 6   + 1 = 1
"E" (1) → 1 * 1   + 1 = 2
총합: 1 + 1 + 1 + 1 + 2 = 6
```

---

## ✅ "AUUUU" 예시

```plaintext
"A" → 0 * 781 + 1 = 1
"U" → 4 * 156 + 1 = 625
"U" → 4 * 31  + 1 = 125
"U" → 4 * 6   + 1 = 25
"U" → 4 * 1   + 1 = 5
총합: 1 + 625 + 125 + 25 + 5 = 781
```
